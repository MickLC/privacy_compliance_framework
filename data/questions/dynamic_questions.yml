# dynamic_questions.yml - Enhanced JSON-Driven Question System
---
objects from file:
  - gdpr_requirements: data/sources/jurisdictions/europe/gdpr_requirements.json
  - ccpa_requirements: data/sources/jurisdictions/united_states/states/california/ccpa_requirements.json
  - tdpsa_requirements: data/sources/jurisdictions/united_states/states/texas/tdpsa_requirements.json
---
code: |
  def load_jurisdiction_specific_questions():
    """Load and organize all questions for applicable jurisdictions from JSON"""
    global jurisdiction_questions, question_queue
    jurisdiction_questions = {}
    question_queue = []
    
    jurisdiction_configs = {
      'gdpr': gdpr_requirements,
      'ccpa': ccpa_requirements,
      'tdpsa': tdpsa_requirements
    }
    
    # Load questions for each applicable jurisdiction
    for jurisdiction_id in applicable_jurisdictions:
      if jurisdiction_id in jurisdiction_configs:
        config = jurisdiction_configs[jurisdiction_id]
        questions = config.get('assessmentQuestions', [])
        jurisdiction_questions[jurisdiction_id] = questions
        
        # Add applicable questions to queue
        for question in questions:
          if should_show_question(question):
            question_id = f"{jurisdiction_id}_{question['id']}"
            question_queue.append({
              'id': question_id,
              'jurisdiction': jurisdiction_id,
              'config': question
            })
    
    return len(question_queue)
  
  def should_show_question(question):
    """Evaluate show_if conditions from JSON"""
    show_if = question.get('show_if')
    if not show_if:
      return True
    
    return evaluate_condition(show_if)
  
  def evaluate_condition(condition):
    """Evaluate conditional logic from JSON"""
    if 'field' in condition:
      # Simple field condition
      field_name = condition['field']
      field_value = globals().get(field_name)
      expected_value = condition.get('value')
      operator = condition.get('operator', 'equals')
      
      if operator == 'contains':
        return expected_value in field_value if field_value else False
      elif operator == 'not_contains':
        return expected_value not in field_value if field_value else True
      elif operator == 'greater_than':
        return field_value > expected_value if field_value else False
      elif operator == 'equals':
        return field_value == expected_value
      else:
        return field_value == expected_value
    
    elif 'and' in condition:
      # AND logic
      return all(evaluate_condition(sub_condition) for sub_condition in condition['and'])
    
    elif 'or' in condition:
      # OR logic  
      return any(evaluate_condition(sub_condition) for sub_condition in condition['or'])
    
    return True
  
  def get_next_question():
    """Get the next unanswered question from the queue"""
    global current_question_index
    
    if not defined('current_question_index'):
      current_question_index = 0
    
    if current_question_index < len(question_queue):
      question_data = question_queue[current_question_index]
      return create_question_block(question_data)
    
    return None  # All questions answered
  
  def create_question_block(question_data):
    """Convert JSON question config to Docassemble question format"""
    question_config = question_data['config']
    jurisdiction = question_data['jurisdiction']
    
    question_text = f"**{jurisdiction.upper()} Assessment**: {question_config['question']}"
    question_type = question_config.get('type', 'text')
    
    # Create appropriate field structure based on type
    if question_type == 'yesno':
      return {
        'question': question_text,
        'field': question_data['id'],
        'datatype': 'yesnowide',
        'help': question_config.get('help', '')
      }
    elif question_type == 'checkboxes':
      return {
        'question': question_text,
        'field': question_data['id'],
        'datatype': 'checkboxes',
        'choices': question_config.get('choices', []),
        'help': question_config.get('help', '')
      }
    elif question_type == 'radio':
      return {
        'question': question_text,
        'field': question_data['id'],
        'datatype': 'radio',
        'choices': question_config.get('choices', []),
        'help': question_config.get('help', '')
      }
    elif question_type == 'integer':
      return {
        'question': question_text,
        'field': question_data['id'],
        'datatype': 'integer',
        'help': question_config.get('help', '')
      }
    elif question_type == 'currency':
      return {
        'question': question_text,
        'field': question_data['id'],
        'datatype': 'currency',
        'help': question_config.get('help', '')
      }
    elif question_type == 'textarea':
      return {
        'question': question_text,
        'field': question_data['id'],
        'datatype': 'area',
        'help': question_config.get('help', '')
      }
    else:
      return {
        'question': question_text,
        'field': question_data['id'],
        'help': question_config.get('help', '')
      }
  
  def advance_question():
    """Move to the next question in the queue"""
    global current_question_index
    current_question_index += 1
---
# Dynamic question display
question: |
  ${ current_question_block['question'] }
field: ${ current_question_block['field'] }
datatype: ${ current_question_block.get('datatype', 'text') }
choices: ${ current_question_block.get('choices', []) }
help: ${ current_question_block.get('help', '') }
---
# Question flow control
code: |
  # Get the current question to display
  current_question_block = get_next_question()
  
  if current_question_block is None:
    # All questions answered
    jurisdiction_questions_complete = True
  else:
    # Show the question, then advance
    need(current_question_block['field'])
    advance_question()
    undefine('current_question_block')
---